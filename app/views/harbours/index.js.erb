// import { loadGeoJson } from '../../javascript/packs/map';

// STEP 1: init map
var mapElement = document.getElementById('map');
var map;
var mapStyle = [
  {
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#f5f5f5"
      }
    ]
  },
  {
    "elementType": "labels",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "elementType": "labels.icon",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#616161"
      }
    ]
  },
  {
    "elementType": "labels.text.stroke",
    "stylers": [
      {
        "color": "#f5f5f5"
      }
    ]
  },
  {
    "featureType": "administrative",
    "elementType": "geometry",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "administrative.country",
    "elementType": "geometry.stroke",
    "stylers": [
      {
        "color": "#a1a1a1"
      },
      {
        "visibility": "on"
      }
    ]
  },
  {
    "featureType": "administrative.land_parcel",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "administrative.land_parcel",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#bdbdbd"
      }
    ]
  },
  {
    "featureType": "administrative.locality",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "administrative.neighborhood",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "administrative.province",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "poi",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#eeeeee"
      },
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "poi",
    "elementType": "labels.text.fill",
    "stylers": [
      {
        "color": "#757575"
      }
    ]
  },
  {
    "featureType": "road",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "geometry",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "labels",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "labels.icon",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road.arterial",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#dadada"
      },
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry.fill",
    "stylers": [
      {
        "visibility": "on"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry.stroke",
    "stylers": [
      {
        "visibility": "off" // on for more road on the map
      }
    ]
  },
  {
    "featureType": "road.local",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "transit",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "water",
    "elementType": "geometry",
    "stylers": [
      {
        "color": "#d2d2d2"
      }
    ]
  }
];

function initMap() {
  if (mapElement) {
    map = new google.maps.Map(mapElement, {
          zoom: 6,
          center: {lat:46.52863469527167, lng:2.43896484375},
          // FR: {lat:46.52863469527167, lng:2.43896484375} // MRS: {lat: 43.3, lng: 5.4}
          styles: mapStyle,
          gestureHandling: 'greedy',
          streetViewControl: false,
          mapTypeControl: false
        });

    // add rectangle, legend, image for Outre Mer (FR)
    var rectangle = new google.maps.Rectangle({
          strokeColor: '#007A8E',
          strokeOpacity: 1,
          strokeWeight: 2,
          // fillColor: '#007A8E',
          fillOpacity: 0,
          map: map,
          bounds: {
            north: 48,
            south: 45,
            east: -6.3,
            west: -7.6
          }
        });

    // // legend
    // OutreMerLegendOverlay = new google.maps.GroundOverlay(
    // // for dev env
    //     'assets/oml.svg',
    // // for prod env
    //     'oml.svg',
    //     {
    //       north: 47.65,
    //       south: 45.35,
    //       east: -7.9,
    //       west: -8.6
    //     });
    // OutreMerLegendOverlay.setMap(map);

    // image
    // https://mapstyle.withgoogle.com/
    // landmarks and labels off
    // sea color: R178 G219 B255 for png on figma
    let omi = `<%= image_path('omi.png') %>`;
    OutreMerImageOverlay = new google.maps.GroundOverlay(
        omi,
        {
          north: 47.90,
          south: 45.1,
          east: -6.3,
          west: -7.6
        });
    OutreMerImageOverlay.setMap(map);

    // country names
    let omn = `<%= image_path('omn.svg') %>`;
    OutreMerNamesOverlay = new google.maps.GroundOverlay(
        omn,
        {
          north: 47.90,
          south: 45.8,
          east: -6.3,
          west: -7.6
        });
    OutreMerNamesOverlay.setMap(map);
  };
}

// STEP 2: load GeoJson UPDATED
// update value of geojson through dataset.geojson == data-geojson
mapElement.dataset.geojson = JSON.stringify(<%= @geojson.to_json.html_safe %>);

function loadGeoJson() {
  if (mapElement) {
    var jsonParsed = JSON.parse(mapElement.dataset.geojson);

    zoom(); // 2.1
    getZoomActual(); // 2.2

    map.data.addGeoJson(jsonParsed);

    console.log("loaded GeoJson:");
    console.log(mapElement.dataset.geojson);

    loadInfoWindows(); // 2.3
  };
}

// 2.1 auto center map on data layer
function zoom() {
  // initialize the bounds
  var bounds = new google.maps.LatLngBounds();
  // loadGeoJson  runs asnchronously, listen to the addfeature-event
  google.maps.event.addListener(map.data, 'addfeature', function(e) {
      // check for points
      if (e.feature.getGeometry().getType() === 'Point') {
        // extend the bounds
        bounds.extend(e.feature.getGeometry().get());
      }
      // use the bounds
      map.fitBounds(bounds);

      // adapt zoom to bounds
      zoomChangeBoundsListener =
        google.maps.event.addListenerOnce(map, 'bounds_changed', function(event) {
          if ( this.getZoom() > 10 ){   // or set a minimum
              this.setZoom(10);  // set zoom here
          }
        });
      setTimeout(function(){google.maps.event.removeListener(zoomChangeBoundsListener)}, 2000);
    });
}

// 2.2 retrieve zoomActual for circles scales
var zoomActual;
function getZoomActual() {
  google.maps.event.addListener(map, 'zoom_changed', function() {
    zoomActual = map.getZoom();
    console.log('zoom actual:' + zoomActual);
    // setFeaturesStyle();
    setFeaturesStyleZoomed();
  });
}

// 2.3 show an info window when the user click on a circle
function loadInfoWindows() {
  var infowindow = new google.maps.InfoWindow();
  map.data.addListener('click', function(event) {
    var myHTML =  '<p class="infowindow-title">'+
                  event.feature.getProperty("name").replace(/(^|\s)[a-z\u00E0-\u00FC]/g, l => l.toUpperCase()) +
                  '</p>' +
                  '<p class="mb0">'+
                  event.feature.getProperty('totvol').toLocaleString(undefined) +
                  " "+
                  event.feature.getProperty('unit') +
                  '</p>'

    infowindow.setContent("<div>"+myHTML+"</div>");
    // infowindow.setContent("<div style='width:100px;'>"+myHTML+"</div>");
    // position the infowindow on the marker
    infowindow.setPosition(event.feature.getGeometry().get());
    // anchor the infowindow on the marker
    infowindow.setOptions({pixelOffset: new google.maps.Size(0,0)});
    infowindow.open(map);
  });
}

// STEP 3: set data style
function setFeaturesStyle() {
  if (mapElement) {
    maxTotvol(); // 3.1
    getZoomBounds(); // 3.2
    map.data.setStyle(function(feature) {
      var totalVolume = feature.getProperty('totvol');
      var displayedTotalVol = displayedVol(totalVolume) // 3.3
      console.log('tot vol ' + feature.getProperty('name') +' = '+ totalVolume);
      console.log('calc scale ' +feature.getProperty('name') +' = '+calcScale(totalVolume));
      return {
        icon: getCircle(totalVolume),
        label: {
          text: displayedTotalVol,
          color: "#17375E"
        }
      };
    });
  };
}

// 3.0bis do it for manual zoom (from 2.2):
function setFeaturesStyleZoomed() {
  if (mapElement) {
    maxTotvol(); // 3.1
    // getZoomBounds(); // 3.2 -> not updated when zoomed manually
    map.data.setStyle(function(feature) {
      var totalVolume = feature.getProperty('totvol');
      var displayedTotalVol = displayedVol(totalVolume) // 3.3
      console.log('tot vol ' + feature.getProperty('name') +' = '+ totalVolume);
      console.log('***calc scale ' +feature.getProperty('name') +' = '+calcScale(totalVolume));
      return {
        icon: getCircle(totalVolume),
        label: {
          text: displayedTotalVol,
          color: "#17375E",
          fontSize: '12px'
        }
      };
    });
  };
}

// 3.1 calculate total volume max of filtered features (from 3.0 and 3.0bis)
var totalVolumeMax = 0;
function maxTotvol() {
  map.data.forEach(function(feature) {
    if (feature.getProperty('totvol') > totalVolumeMax) {
      totalVolumeMax = feature.getProperty('totvol');
    };
  });
  console.log('total vol max = '+ totalVolumeMax);
}

// 3.2 calculate zoomBounds for circles scales (from 3.0 only)
var zoomBounds;
function getZoomBounds() {
    zoomBounds = map.getZoom();
    if (zoomBounds > 10) {
      zoomBounds = 10
    }
    console.log('zoom bounds:' + zoomBounds);
}

// 3.3 calcl vol to display on circles (from 3.0 and 3.0bis)
function displayedVol(totalVolume) {
  // var displayedVol = (Math.round(totalVolume *100 / (maxPowTen())) / 100); // for proportional units
  var displayedVol = ""
  if (unitScaleText() == " millions de ") {
    rounding = (Math.round(totalVolume * 100 / 1000000) / 100);
    if (rounding < 0.01) {
      displayedVol = "<0.01";
    } else {
      displayedVol = rounding.toString();
    }
  } else if (unitScaleText() == " milliers de ") {
    rounding = (Math.round(totalVolume * 100 / 1000) / 100);
    if (rounding < 0.01) {
      displayedVol = "<0.01";
    } else {
      displayedVol = rounding.toString();
    }
  } else {
    rounding = (Math.round(totalVolume * 100) / 100);
    if (rounding < 0.01) {
      displayedVol = "<0.01";
    } else {
      displayedVol = rounding.toString();
    }
  }
  // console.log('2 digit total vol = '+ displayedVol);
  return displayedVol;
}

// 3.0.1 show proportional markers (note: markers ares symbols == circles)
function getCircle(totalVolume) {
  return {
    path: google.maps.SymbolPath.CIRCLE,
    fillColor: '#00bcdb',
    fillOpacity: 0.9,
    scale: calcScale(totalVolume),
    strokeColor: '#17375E',
    strokeWeight: 0
  };
}

// 3.0.2 calc scale for circles scales
function calcScale(totalVolume) {
  var scale = (Math.sqrt(totalVolume * Math.pow(40, 2) / totalVolumeMax));
  // console.log('scale = '+ scale);
  if (scale < 3) {
    scale = 3;
  }
  scale = scale * zoomActual / zoomBounds;
  // console.log('zoom scale final:' + scale)
  return scale;
}

// 3.4 from 4.1 add unit on top left corner of the map
function addUnitLegend() {
  var unitSelectedFamily = ""
  map.data.forEach(function(feature) {
    unitSelectedFamily = feature.getProperty('unit');
  });

  var legend = document.querySelector('#legend')
  // var maxPowTenToLocaleString = maxPowTen().toLocaleString(undefined);
  // legend.innerText = `Unité : ${maxPowTenToLocaleString} ${unitSelectedFamily}`
  legend.innerText = `Unité : ${unitScaleText()} ${unitSelectedFamily}`
  // map.controls[google.maps.ControlPosition.LEFT_TOP].push(legend)
}

// 3.4.1 calc unit from legend
function unitScaleText() {
  var unitScaleText = ""
  if (maxPowTen() >= 1000000) {
    unitScaleText = " millions de "
  } else if (maxPowTen() >= 1000) {
    unitScaleText = " milliers de "
  }
  return unitScaleText
}

// 3.4.2 calculate max displayed totalVolume pow of 10
function maxPowTen() {
  var totVolLength = totalVolumeMax.toString().length;
  var maxPowTen = (Math.pow(10, totVolLength)) / 10;
  return maxPowTen;
}

// STEP 4: reload subfamilies drop down
// 4.1 reload of subfamilies1 (for each change in family or subfamilies1)
function loadSubfamilies1() {

  var select2Subfamilies1 = '<%= @subfamilies1.to_json.html_safe %>'; // ok
  var subfamilies1Parsed = JSON.parse(select2Subfamilies1); // ok

  var prevOptions = document.querySelectorAll('#select2_subfamilies1 option'); // ok
  var selectId = document.getElementById('select2_subfamilies1'); // ok
  // notes for console.log below(1)

  // creating new dropdown options only when selecting a new family (not when selecting subfamilies1)
  if (prevOptions.length == 0) {
    // iteration on @subfamilies1 parsed to create new dropdow options
    subfamilies1Parsed.forEach(function(sf) {
      var newOpt = document.createElement('option');
      var code;
      var label;
      for (var k in sf) {
        // console.log('key is: ' + k + ', value is: ' + sf[k]);
        if (k === "code") {
          code = sf[k];
        } else {
          label = sf[k];
        }
      }
      newOpt.value = code;
      newOpt.innerText = code.toUpperCase() + ' - ' + label.replace(/(^|\s)[a-z\u00E0-\u00FC]/g, l => l.toUpperCase());
      selectId.appendChild(newOpt);
    });
  }

  addUnitLegend(); // 3.4

}

// 4.2 reload of subfamilies2 (for each change in family or subfamilies2)
function loadSubfamilies2() {

  var select2Subfamilies2 = '<%= @subfamilies2.to_json.html_safe %>'; // ok
  var subfamilies2Parsed = JSON.parse(select2Subfamilies2); // ok

  var prevOptions = document.querySelectorAll('#select2_subfamilies2 option'); // ok
  var selectId = document.getElementById('select2_subfamilies2'); // ok
  // notes for console.log below(1)

  // creating new dropdown options only when selecting a new family (not when selecting subfamilies2)
  if (prevOptions.length == 0) {
    // iteration on @subfamilies2 parsed to create new dropdow options
    subfamilies2Parsed.forEach(function(sf) {
      var newOpt = document.createElement('option');
      var code;
      var label;
      for (var k in sf) {
        // console.log('key is: ' + k + ', value is: ' + sf[k]);
        if (k === "code") {
          code = sf[k];
        } else {
          label = sf[k];
        }
      }
      newOpt.value = code;
      newOpt.innerText = code.toUpperCase() + ' - ' + label.replace(/(^|\s)[a-z\u00E0-\u00FC]/g, l => l.toUpperCase());
      selectId.appendChild(newOpt);
    });
  }
}

// 4.3 reload of subfamilies3 (for each change in family or subfamilies3)
function loadSubfamilies3() {

  var select2Subfamilies3 = '<%= @subfamilies3.to_json.html_safe %>'; // ok
  var subfamilies3Parsed = JSON.parse(select2Subfamilies3); // ok

  var prevOptions = document.querySelectorAll('#select2_subfamilies3 option'); // ok
  var selectId = document.getElementById('select2_subfamilies3'); // ok
  // notes for console.log below(1)

  // creating new dropdown options only when selecting a new family (not when selecting subfamilies3)
  if (prevOptions.length == 0) {
    // iteration on @subfamilies3 parsed to create new dropdow options
    subfamilies3Parsed.forEach(function(sf) {
      var newOpt = document.createElement('option');
      var code;
      var label;
      for (var k in sf) {
        // console.log('key is: ' + k + ', value is: ' + sf[k]);
        if (k === "code") {
          code = sf[k];
        } else {
          label = sf[k];
        }
      }
      newOpt.value = code;
      newOpt.innerText = code.toUpperCase() + ' - ' + label.replace(/(^|\s)[a-z\u00E0-\u00FC]/g, l => l.toUpperCase());
      selectId.appendChild(newOpt);
    });
  }
}

// execution
initMap(); // STEP 1
loadGeoJson(); // STEP 2
setFeaturesStyle(); // STEP 3
loadSubfamilies1(); // STEP 4.1
loadSubfamilies2(); // STEP 4.2
loadSubfamilies3(); // STEP 4.3

// notes for console.log(1)
  // console.log("new select2Subfamilies1:");
  // console.log(subfamilies1Parsed);
  // console.log(typeof subfamilies1Parsed);

  // console.log("temp select2Subfamilies1:"); // used for testing
  // console.log(document.getElementById('temp_subfamilies1').dataset.temp);
  // document.getElementById('temp_subfamilies1').dataset.temp = select2Subfamilies1 //ok

  // console.log("updated temp select2Subfamilies1:");
  // console.log(document.getElementById('temp_subfamilies1').dataset.temp); // ok
  // [{"code":"a1","label":"vrac liquide"},{"code":"a2","label":"vrac solide"},{"code":"a3","label":"non vrac"}]

  // console.log("prevOptions: ");
  // console.log(prevOptions); // ok
  // console.log(typeof prevOptions);
  // console.log(prevOptions.length); // ok
