// import { loadGeoJson } from '../../javascript/packs/map';

// STEP 1: init map
var mapElement = document.getElementById('map');
var map;
var mapStyle = [
  {
    "featureType": "poi",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "labels.icon",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "transit",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  }
];
function initMap() {
  if (mapElement) {
    map = new google.maps.Map(mapElement, {
          zoom: 6,
          center: {lat:46.52863469527167, lng:2.43896484375},
          // FR: {lat:46.52863469527167, lng:2.43896484375} // MRS: {lat: 43.3, lng: 5.4}
          styles: mapStyle,
          gestureHandling: 'greedy',
          streetViewControl: false,
          mapTypeControl: false
        });

  };
}

// STEP 2: load GeoJson UPDATED
// update value of geojson through dataset.geojson == data-geojson
mapElement.dataset.geojson = JSON.stringify(<%= @geojson.to_json.html_safe %>);

function loadGeoJson() {
  if (mapElement) {
    var jsonParsed = JSON.parse(mapElement.dataset.geojson);

    zoom();

    map.data.addGeoJson(jsonParsed);

    console.log("loaded GeoJson:");
    console.log(mapElement.dataset.geojson);
  };
}

// auto center map on data layer
function zoom() {
    // initialize the bounds
    var bounds = new google.maps.LatLngBounds();
    // loadGeoJson  runs asnchronously, listen to the addfeature-event
    google.maps.event.addListener(map.data, 'addfeature', function(e) {
        // check for points
        if (e.feature.getGeometry().getType() === 'Point') {
          // extend the bounds
          bounds.extend(e.feature.getGeometry().get());
        }
        // use the bounds
        map.fitBounds(bounds);

        // adapt zoom to bounds
        // var z = map.getZoom();
        // console.log(z);
        zoomChangeBoundsListener =
            google.maps.event.addListenerOnce(map, 'bounds_changed', function(event) {
                if ( this.getZoom() > 10 ){   // or set a minimum
                    this.setZoom(10);  // set zoom here
                }
        });
        setTimeout(function(){google.maps.event.removeListener(zoomChangeBoundsListener)}, 2000);
        // var z = map.getZoom();
        // console.log(z);
      });
}

// STEP 3: set data style
function setFeaturesStyle() {
  if (mapElement) {
    maxTotvol();

    map.data.setStyle(function(feature) {
      var totalVolume = feature.getProperty('totvol');
      var twoDigitTotalVol = twoDigitVol(totalVolume)
      console.log('tot vol ' + feature.getProperty('name') +' = '+ totalVolume);
      return {
        icon: getCircle(totalVolume),
        label: {
          text: twoDigitTotalVol,
          color: "white"
        }
      };
    });
  };
}

// calculate total volume max of filtered features
var totalVolumeMax = 0;
function maxTotvol() {
  map.data.forEach(function(feature) {
    if (feature.getProperty('totvol') > totalVolumeMax) {
      totalVolumeMax = feature.getProperty('totvol');
    };
  });
  console.log('total vol max = '+ totalVolumeMax);
}

// show proportional markers (note: markers ares symbols == circles)
function getCircle(totalVolume) {
  return {
    path: google.maps.SymbolPath.CIRCLE,
    fillColor: '#007A8E',
    fillOpacity: 1,
    scale: calcScale(totalVolume),
    strokeColor: '#007A8E',
    strokeWeight: 1
  };
}

function calcScale(totalVolume) {
  var scale = (Math.sqrt(totalVolume * Math.pow(40, 2) / totalVolumeMax));
  // console.log('scale = '+ scale);
  return scale;
}

// calculate totalVolume twoDigit rounding
function maxPowTen() {
  var totVolLength = totalVolumeMax.toString().length;
  var maxPowTen = (Math.pow(10, totVolLength)) / 10;
  return maxPowTen;
}

function twoDigitVol(totalVolume) {
  var twoDigitVol = (Math.round(totalVolume *100 / (maxPowTen())) / 100);
  // console.log('2 digit total vol = '+ twoDigitVol);
  return twoDigitVol;
}


// add unit below family field
function addUnitBelowFamilyField() {
  var unitSelectedFamily = ""
  map.data.forEach(function(feature) {
    unitSelectedFamily = feature.getProperty('unit');
  });

  var unitDisplay = document.querySelector('#unit-display')
  var maxPowTenToLocaleString = maxPowTen().toLocaleString(undefined);
  unitDisplay.innerText = `Unit√©: ${maxPowTenToLocaleString} ${unitSelectedFamily}`
}

// reload of subfamilies1 (for each change in family or subfamilies1)
function loadSubfamilies1() {

  var select2Subfamilies1 = '<%= @subfamilies1.to_json.html_safe %>'; // ok
  var subfamilies1Parsed = JSON.parse(select2Subfamilies1); // ok

  var prevOptions = document.querySelectorAll('#select2_subfamilies1 option'); // ok
  var selectId = document.getElementById('select2_subfamilies1'); // ok
  // notes for console.log below(1)

  // creating new dropdown options only when selecting a new family (not when selecting subfamilies1)
  if (prevOptions.length == 0) {
    // iteration on @subfamilies1 parsed to create new dropdow options
    subfamilies1Parsed.forEach(function(sf) {
      var newOpt = document.createElement('option');
      var code;
      var label;
      for (var k in sf) {
        // console.log('key is: ' + k + ', value is: ' + sf[k]);
        if (k === "code") {
          code = sf[k];
        } else {
          label = sf[k];
        }
      }
      newOpt.value = code;
      newOpt.innerText = code.toUpperCase() + ' - ' + label.replace(/\b\w/g, l => l.toUpperCase());
      selectId.appendChild(newOpt);
    });
  }

  addUnitBelowFamilyField()
}

// reload of subfamilies2 (for each change in family or subfamilies2)
function loadSubfamilies2() {

  var select2Subfamilies2 = '<%= @subfamilies2.to_json.html_safe %>'; // ok
  var subfamilies2Parsed = JSON.parse(select2Subfamilies2); // ok

  var prevOptions = document.querySelectorAll('#select2_subfamilies2 option'); // ok
  var selectId = document.getElementById('select2_subfamilies2'); // ok
  // notes for console.log below(1)

  // creating new dropdown options only when selecting a new family (not when selecting subfamilies2)
  if (prevOptions.length == 0) {
    // iteration on @subfamilies2 parsed to create new dropdow options
    subfamilies2Parsed.forEach(function(sf) {
      var newOpt = document.createElement('option');
      var code;
      var label;
      for (var k in sf) {
        // console.log('key is: ' + k + ', value is: ' + sf[k]);
        if (k === "code") {
          code = sf[k];
        } else {
          label = sf[k];
        }
      }
      newOpt.value = code;
      newOpt.innerText = code.toUpperCase() + ' - ' + label.replace(/\b\w/g, l => l.toUpperCase());
      selectId.appendChild(newOpt);
    });
  }
}

// reload of subfamilies3 (for each change in family or subfamilies3)
function loadSubfamilies3() {

  var select2Subfamilies3 = '<%= @subfamilies3.to_json.html_safe %>'; // ok
  var subfamilies3Parsed = JSON.parse(select2Subfamilies3); // ok

  var prevOptions = document.querySelectorAll('#select2_subfamilies3 option'); // ok
  var selectId = document.getElementById('select2_subfamilies3'); // ok
  // notes for console.log below(1)

  // creating new dropdown options only when selecting a new family (not when selecting subfamilies3)
  if (prevOptions.length == 0) {
    // iteration on @subfamilies3 parsed to create new dropdow options
    subfamilies3Parsed.forEach(function(sf) {
      var newOpt = document.createElement('option');
      var code;
      var label;
      for (var k in sf) {
        // console.log('key is: ' + k + ', value is: ' + sf[k]);
        if (k === "code") {
          code = sf[k];
        } else {
          label = sf[k];
        }
      }
      newOpt.value = code;
      newOpt.innerText = code.toUpperCase() + ' - ' + label.replace(/\b\w/g, l => l.toUpperCase());
      selectId.appendChild(newOpt);
    });
  }
}
// execution
initMap();
loadGeoJson();
setFeaturesStyle();
loadSubfamilies1();
loadSubfamilies2();
loadSubfamilies3();


// notes for console.log(1)
  // console.log("new select2Subfamilies1:");
  // console.log(subfamilies1Parsed);
  // console.log(typeof subfamilies1Parsed);

  // console.log("temp select2Subfamilies1:"); // used for testing
  // console.log(document.getElementById('temp_subfamilies1').dataset.temp);
  // document.getElementById('temp_subfamilies1').dataset.temp = select2Subfamilies1 //ok

  // console.log("updated temp select2Subfamilies1:");
  // console.log(document.getElementById('temp_subfamilies1').dataset.temp); // ok
  // [{"code":"a1","label":"vrac liquide"},{"code":"a2","label":"vrac solide"},{"code":"a3","label":"non vrac"}]

  // console.log("prevOptions: ");
  // console.log(prevOptions); // ok
  // console.log(typeof prevOptions);
  // console.log(prevOptions.length); // ok
