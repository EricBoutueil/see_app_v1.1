// TO DO: NOT ABLE TO IMPORT FUNCTIONS FROM WEBPACK FILES INTO INDEX.JS.ERB

// import { loadGeoJson } from '../../javascript/packs/map';

// import { log } from "./console_log"; // -> not working, so instead:
if(window.location.href.indexOf("localhost") >= 0) {
   var DEBUG = false;
}

function log(a, b, c, d) {
  if(DEBUG) {
    console.log(a, b, c, d);
  }
}

// index.js.erb

// STEP 1: init map
var mapElement = document.getElementById('map');
var map;
var mapStyle = [
  {
    "elementType": "labels",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "administrative",
    "elementType": "geometry",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "administrative.country",
    "elementType": "geometry.stroke",
    "stylers": [
      {
        "visibility": "on"
      }
    ]
  },
  {
    "featureType": "poi",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road",
    "elementType": "geometry",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry.fill",
    "stylers": [
      {
        "visibility": "on"
      }
    ]
  },
  {
    "featureType": "road.highway",
    "elementType": "geometry.stroke",
    "stylers": [
      {
        "visibility": "off" // on for more road on the map
      }
    ]
  },
  {
    "featureType": "transit",
    "stylers": [
      {
        "visibility": "off"
      }
    ]
  }
];

function initMap() {
  if (mapElement) {
    map = new google.maps.Map(mapElement, {
          zoom: 6,
          center: {lat:46.52863469527167, lng:2.43896484375},
          // FR: {lat:46.52863469527167, lng:2.43896484375} // MRS: {lat: 43.3, lng: 5.4}
          styles: mapStyle,
          gestureHandling: 'greedy',
          streetViewControl: false,
          mapTypeControl: false
        });

    // add rectangle, legend, image for Outre Mer (FR)
    var rectangle = new google.maps.Rectangle({
          strokeColor: '#007A8E',
          strokeOpacity: 1,
          strokeWeight: 2,
          // fillColor: '#007A8E',
          fillOpacity: 0,
          map: map,
          bounds: {
            north: 48.5,
            south: 44.5,
            east: -6.3,
            west: -7.6
          }
        });

    // image
    // https://mapstyle.withgoogle.com/
    // parameters' scales: 1 / 1 / 0
    // sea color: R178 G219 B255 (#B2DBFF) for png on figma
    let omi = `<%= image_path('omi.png') %>`;
    OutreMerImageOverlay = new google.maps.GroundOverlay(
        omi,
        {
          north: 48.4,
          south: 44.6,
          east: -6.3,
          west: -7.6
        });
    OutreMerImageOverlay.setMap(map);

    // country names
    let omn = `<%= image_path('omn.svg') %>`;
    OutreMerNamesOverlay = new google.maps.GroundOverlay(
        omn,
        {
          north: 48.3,
          south: 45.2,
          east: -6.3,
          west: -7.6
        });
    OutreMerNamesOverlay.setMap(map);
  };
}

// STEP 2: load GeoJson UPDATED
// 2.0 update value of geojson through dataset.geojson == data-geojson
mapElement.dataset.geojson = JSON.stringify(<%= @geojson.to_json.html_safe %>);

function loadGeoJson() {
  if (mapElement) {
    var jsonParsed = JSON.parse(mapElement.dataset.geojson);

    zoom(); // 2.1
    getZoomActual(); // 2.2

    map.data.addGeoJson(jsonParsed);

    log("loaded GeoJson:");
    log(mapElement.dataset.geojson);

    loadInfoWindows(); // 2.3
  };
}

// 2.1 auto center map on data layer
function zoom() {
  // initialize the bounds
  var bounds = new google.maps.LatLngBounds();
  // loadGeoJson  runs asnchronously, listen to the addfeature-event
  google.maps.event.addListener(map.data, 'addfeature', function(e) {
      // check for points
      if (e.feature.getGeometry().getType() === 'Point') {
        // extend the bounds
        bounds.extend(e.feature.getGeometry().get());
      }
      // use the bounds
      map.fitBounds(bounds);

      // adapt zoom to bounds
      zoomChangeBoundsListener =
        google.maps.event.addListenerOnce(map, 'bounds_changed', function(event) {
          if ( this.getZoom() > 10 ) {   // or set a minimum
            this.setZoom(10);  // set zoom here
          } else if ( this.getZoom() < 6 ) {
            var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (!isMobile) {
              // set min zoom if FR only
              var france = ['fr', 'FR', 'france', 'France', 'FRANCE']
              map.data.forEach(function(feature) {
                if (france.includes(feature.getProperty('country'))){
                  franceOnly = true;
                };
              });
              if (franceOnly) {
                this.setZoom(6);
              }
            }
          }
        });
      setTimeout(function(){google.maps.event.removeListener(zoomChangeBoundsListener)}, 2000);
    });
}

// 2.2 retrieve zoomActual for circles scales
var zoomActual;
function getZoomActual() {
  google.maps.event.addListener(map, 'zoom_changed', function() {
    zoomActual = map.getZoom();
    log('zoom actual:' + zoomActual);
    // setFeaturesStyle();
    setFeaturesStyleZoomed();
  });
}

// 2.3 show an info window when the user click on a circle
function loadInfoWindows() {
  var infowindow = new google.maps.InfoWindow();
  map.data.addListener('click', function(event) {
    var myHTML =  '<p class="infowindow-title">'+
                  event.feature.getProperty("name").replace(/(^|\s)[a-z\u00E0-\u00FC]/g, l => l.toUpperCase()) +
                  '</p>' +
                  '<p class="mb0">'+
                  event.feature.getProperty('totvol').toLocaleString(undefined) +
                  " "+
                  event.feature.getProperty('unit') +
                  '</p>'

    infowindow.setContent("<div>"+myHTML+"</div>");
    // infowindow.setContent("<div style='width:100px;'>"+myHTML+"</div>");
    // position the infowindow on the marker
    infowindow.setPosition(event.feature.getGeometry().get());
    // anchor the infowindow on the marker
    infowindow.setOptions({pixelOffset: new google.maps.Size(0,0)});
    infowindow.open(map);
  });
}

// STEP 3: set data style
// 3.0 create a circle for each feature
function setFeaturesStyle() {
  if (mapElement) {
    maxTotvol(); // 3.1
    getZoomBounds(); // 3.2
    map.data.setStyle(function(feature) {
      var totalVolume = feature.getProperty('totvol');
      var displayedTotalVol = displayedVol(totalVolume) // 3.3
      log('tot vol ' + feature.getProperty('name') +' = '+ totalVolume);
      log('calc scale ' +feature.getProperty('name') +' = '+calcScale(totalVolume));
      return {
        icon: getCircle(totalVolume), // 3.4
        label: {
          text: displayedTotalVol,
          color: "#17375E"
        }
      };
    });
  };
}

// 3.0bis do it for manual zoom (from 2.2):
function setFeaturesStyleZoomed() {
  if (mapElement) {
    maxTotvol(); // 3.1
    // getZoomBounds(); // 3.2 -> not updated when zoomed manually
    map.data.setStyle(function(feature) {
      var totalVolume = feature.getProperty('totvol');
      var displayedTotalVol = displayedVol(totalVolume) // 3.3
      log('tot vol ' + feature.getProperty('name') +' = '+ totalVolume);
      log('***calc scale ' +feature.getProperty('name') +' = '+calcScale(totalVolume));
      return {
        icon: getCircle(totalVolume), // 3.4
        label: {
          text: displayedTotalVol,
          color: "#17375E",
          fontSize: '12px'
        }
      };
    });
  };
}

// 3.1 calculate total volume max of filtered features (from 3.0 and 3.0bis)
var totalVolumeMax = 0;
function maxTotvol() {
  map.data.forEach(function(feature) {
    if (feature.getProperty('totvol') > totalVolumeMax) {
      totalVolumeMax = feature.getProperty('totvol');
    };
  });
  log('total vol max = '+ totalVolumeMax);
}

// 3.2 calculate zoomBounds for circles scales (from 3.0 only)
var zoomBounds;
function getZoomBounds() {
    zoomBounds = map.getZoom();
    if (zoomBounds > 10) {
      zoomBounds = 10
    }
    log('zoom bounds:' + zoomBounds);
}

// 3.3 calcl vol to display on circles (from 3.0 and 3.0bis)
function displayedVol(totalVolume) {
  // var displayedVol = (Math.round(totalVolume *100 / (maxPowTen())) / 100); // for proportional units
  var displayedVol = ""
  if (unitScaleText() == " millions ") {
    rounding = (Math.round(totalVolume * 100 / 1000000) / 100);
    if (rounding < 0.01) {
      displayedVol = "<0.01";
    } else {
      displayedVol = rounding.toString();
    }
  } else if (unitScaleText() == " milliers ") {
    rounding = (Math.round(totalVolume * 100 / 1000) / 100);
    if (rounding < 0.01) {
      displayedVol = "<0.01";
    } else {
      displayedVol = rounding.toString();
    }
  } else {
    rounding = (Math.round(totalVolume * 100) / 100);
    if (rounding < 0.01) {
      displayedVol = "<0.01";
    } else {
      displayedVol = rounding.toString();
    }
  }
  // log('2 digit total vol = '+ displayedVol);
  return displayedVol;
}

// 3.4 show proportional markers (note: markers ares symbols == circles)
function getCircle(totalVolume) {
  return {
    path: google.maps.SymbolPath.CIRCLE,
    fillColor: '#00bcdb',
    fillOpacity: 0.9,
    scale: calcScale(totalVolume), // 3.4.1
    strokeColor: '#17375E',
    strokeWeight: 0
  };
}

// 3.4.1 calc scale for circles scales
function calcScale(totalVolume) {
  var scale = (Math.sqrt(totalVolume * Math.pow(40, 2) / totalVolumeMax));
  // log('scale = '+ scale);
  if (scale < 3) {
    scale = 3;
  }
  scale = scale * zoomActual / zoomBounds;
  // log('zoom scale final:' + scale)
  return scale;
}

// 3.5 from 4.1 add legend (unit on top left corner of the map)
function addUnitLegend() {
  var legend = document.querySelector('#legend')
  // var maxPowTenToLocaleString = maxPowTen().toLocaleString(undefined);
  // legend.innerText = `Unité : ${maxPowTenToLocaleString} ${unitSelectedFamily}`
  legend.innerText = `Unité : ${unitScaleText()} ${unitSelectedFamily()}` // 3.5.1&3
  // map.controls[google.maps.ControlPosition.LEFT_TOP].push(legend)
}

// 3.5.1 calc unit from legend
function unitScaleText() {
  var unitScaleText = ""
  if (maxPowTen() >= 1000000) { // 3.5.2
    unitScaleText = " millions "
  } else if (maxPowTen() >= 1000) { // 3.5.2
    unitScaleText = " milliers "
  }
  return unitScaleText
}

// 3.5.2 calculate max displayed totalVolume pow of 10
function maxPowTen() {
  var totVolLength = totalVolumeMax.toString().length;
  var maxPowTen = (Math.pow(10, totVolLength)) / 10;
  return maxPowTen;
}

// 3.5.3 identify unit family
function unitSelectedFamily() {
  var unitSelectedFamily = ""
  map.data.forEach(function(feature) {
    unitSelectedFamily = feature.getProperty('unit');
  });
  var firstLetter = unitSelectedFamily.substr(0, 1);
  var vowels = ["a", "e", "i", "o", "u", "y"];
  if (vowels.includes(firstLetter)){
    return `d\'${unitSelectedFamily}`;
  }
  else {
    return `de ${unitSelectedFamily}`;
  }
}

// STEP 4: reload subfamilies drop down
// 4.1 reload of subfamilies1 (for each change in family or subfamilies1)
function loadSubfamilies1() {

  var select2Subfamilies1 = '<%= @subfamilies1.to_json.html_safe %>'; // ok
  var subfamilies1Parsed = JSON.parse(select2Subfamilies1); // ok

  var prevOptions = document.querySelectorAll('#select2_subfamilies1 option'); // ok
  var selectId = document.getElementById('select2_subfamilies1'); // ok
  // notes for log below(1)

  // creating new dropdown options only when selecting a new family (not when selecting subfamilies1)
  if (prevOptions.length == 0) {
    // iteration on @subfamilies1 parsed to create new dropdow options
    subfamilies1Parsed.forEach(function(subf) {
      var newOpt = document.createElement('option');
      var code;
      var label;
      for (var key in subf) {
        // log('key is: ' + key + ', value is: ' + subf[key]);
        if (key === "code") {
          code = subf[key];
        } else {
          label = subf[key];
        }
      }
      newOpt.value = code;
      newOpt.innerText = label.charAt(0).toUpperCase() + label.slice(1);
      selectId.appendChild(newOpt);
    });
  }

  addUnitLegend(); // 3.5

}

// 4.2 reload of subfamilies2 (for each change in family or subfamilies2)
function loadSubfamilies2() {

  var select2Subfamilies2 = '<%= @subfamilies2.to_json.html_safe %>'; // ok
  var subfamilies2Parsed = JSON.parse(select2Subfamilies2); // ok

  var prevOptions = document.querySelectorAll('#select2_subfamilies2 option'); // ok
  var selectId = document.getElementById('select2_subfamilies2'); // ok
  // notes for log below(1)

  // creating new dropdown options only when selecting a new family (not when selecting subfamilies2)
  if (prevOptions.length == 0) {
    // iteration on @subfamilies2 parsed to create new dropdow options
    subfamilies2Parsed.forEach(function(subf) {
      var newOpt = document.createElement('option');
      var code;
      var label;
      for (var key in subf) {
        // log('key is: ' + key + ', value is: ' + subf[key]);
        if (key === "code") {
          code = subf[key];
        } else {
          label = subf[key];
        }
      }
      newOpt.value = code;
      newOpt.innerText = label.charAt(0).toUpperCase() + label.slice(1);
      selectId.appendChild(newOpt);
    });
  }
}

// 4.3 reload of subfamilies3 (for each change in family or subfamilies3)
function loadSubfamilies3() {

  var select2Subfamilies3 = '<%= @subfamilies3.to_json.html_safe %>'; // ok
  var subfamilies3Parsed = JSON.parse(select2Subfamilies3); // ok

  var prevOptions = document.querySelectorAll('#select2_subfamilies3 option'); // ok
  var selectId = document.getElementById('select2_subfamilies3'); // ok
  // notes for log below(1)

  // creating new dropdown options only when selecting a new family (not when selecting subfamilies3)
  if (prevOptions.length == 0) {
    // iteration on @subfamilies3 parsed to create new dropdow options
    subfamilies3Parsed.forEach(function(subf) {
      var newOpt = document.createElement('option');
      var code;
      var label;
      for (var key in subf) {
        // log('key is: ' + key + ', value is: ' + subf[key]);
        if (key === "code") {
          code = subf[key];
        } else {
          label = subf[key];
        }
      }
      newOpt.value = code;
      newOpt.innerText = label.charAt(0).toUpperCase() + label.slice(1);
      selectId.appendChild(newOpt);
    });
  }
}

// execution
if (map === undefined) {
  initMap(); // STEP 1
}
loadGeoJson(); // STEP 2
setFeaturesStyle(); // STEP 3
loadSubfamilies1(); // STEP 4.1
loadSubfamilies2(); // STEP 4.2
loadSubfamilies3(); // STEP 4.3

// notes for log(1)
  // log("new select2Subfamilies1:");
  // log(subfamilies1Parsed);
  // log(typeof subfamilies1Parsed);

  // log("temp select2Subfamilies1:"); // used for testing
  // log(document.getElementById('temp_subfamilies1').dataset.temp);
  // document.getElementById('temp_subfamilies1').dataset.temp = select2Subfamilies1 //ok

  // log("updated temp select2Subfamilies1:");
  // log(document.getElementById('temp_subfamilies1').dataset.temp); // ok
  // [{"code":"a1","label":"vrac liquide"},{"code":"a2","label":"vrac solide"},{"code":"a3","label":"non vrac"}]

  // log("prevOptions: ");
  // log(prevOptions); // ok
  // log(typeof prevOptions);
  // log(prevOptions.length); // ok
